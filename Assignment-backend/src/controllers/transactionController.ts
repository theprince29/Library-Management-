import { Request, Response } from 'express';
import Transaction from '../models/Transaction.model.js';
import User from '../models/User.model.js';
import Book from '../models/Book.model.js';









export const getAllTransactions = async (req: Request, res: Response) => {
    try {
      const transactions = await Transaction.find().populate('bookName userId');
      return res.status(200).json({ transactions });
    } catch (error) {
      return res.status(500).json({ message: 'Error fetching transactions', error });
    }
  };





// Issue a book to a user
export const issueBook = async (req: Request, res: Response) => {
  const { bookName, userId, issueDate } = req.body;

  try {
    // Validate User and Book existence
    const user = await User.findOne({ userId });
    if (!user) return res.status(404).json({ message: 'User not found' });

    const book = await Book.findOne({ bookName });
    if (!book) return res.status(404).json({ message: 'Book not found' });

    // Check if the book is already issued
    const existingTransaction = await Transaction.findOne({ bookName, returnDate: { $exists: false } });
    if (existingTransaction) return res.status(400).json({ message: 'Book is already issued' });

    // Create a new transaction
    const newTransaction = new Transaction({
      bookName,
      userId,
      issueDate: new Date(issueDate),
    });

    await newTransaction.save();
    return res.status(201).json({ message: 'Book issued successfully', newTransaction });
  } catch (error) {
    return res.status(500).json({ message: 'Error issuing book', error });
  }
};

// Return a book and calculate rent
export const returnBook = async (req: Request, res: Response) => {
  const { bookName, userId, returnDate } = req.body;

  try {
    const transaction = await Transaction.findOne({
      bookName,
      userId,
      returnDate: { $exists: false }, // Book is currently issued
    });

    if (!transaction) return res.status(404).json({ message: 'No active transaction found' });

    const issueDate = new Date(transaction.issueDate);
    const returnDateObj = new Date(returnDate);
    const diffTime = Math.abs(returnDateObj.getTime() - issueDate.getTime());
    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

    const book = await Book.findOne({  bookName });
    if (!book) return res.status(404).json({ message: 'Book not found' });

    const rentCost = diffDays * (book.rentPerDay || 0);

    transaction.returnDate = returnDateObj;
    transaction.rentCost = rentCost;

    await transaction.save();
    return res.status(200).json({ message: 'Book returned successfully', transaction });
  } catch (error) {
    return res.status(500).json({ message: 'Error returning book', error });
  }
};

// Get users who have issued a book and its current status
export const getBookTransactions = async (req: Request, res: Response) => {
  const { bookName } = req.params;

  try {
    const transactions = await Transaction.find({ bookName }).populate('userId');
    const currentlyIssued = transactions.find(t => !t.returnDate);
    const totalCount = transactions.length;

    return res.status(200).json({
      totalCount,
      currentlyIssued: currentlyIssued ? currentlyIssued.userId : 'Not issued currently',
    });
  } catch (error) {
    return res.status(500).json({ message: 'Error fetching book transactions', error });
  }
};

// Get total rent generated by a book
export const getTotalRentByBook = async (req: Request, res: Response) => {
  const { bookName } = req.params;

  try {
    const transactions = await Transaction.find({ bookName, rentCost: { $exists: true } });
    const totalRent = transactions.reduce((acc, transaction) => acc + (transaction.rentCost || 0), 0);

    return res.status(200).json({ totalRent });
  } catch (error) {
    return res.status(500).json({ message: 'Error calculating total rent', error });
  }
};

// Get all books issued to a specific user
export const getUserBooks = async (req: Request, res: Response) => {
  const { userId } = req.params;

  try {
    const transactions = await Transaction.find({ userId }).populate('bookName');
    return res.status(200).json({ transactions });
  } catch (error) {
    return res.status(500).json({ message: 'Error fetching user transactions', error });
  }
};

// Get books issued within a date range
export const getBooksIssuedInRange = async (req: Request, res: Response) => {
  const { startDate, endDate } = req.query;

  try {
    const start = new Date(startDate as string);
    const end = new Date(endDate as string);

    if (isNaN(start.getTime()) || isNaN(end.getTime())) {
      return res.status(400).json({ message: 'Invalid date format' });
    }

    console.log('Fetching transactions between:', start, 'and', end); // For debugging

    const transactions = await Transaction.find({
      issueDate: {
        $gte: start,
        $lte: end,
      },
    }).populate('bookName userId'); // Ensure bookName is defined properly

    if (!transactions || transactions.length === 0) {
      return res.status(404).json({ message: 'No transactions found in this date range' });
    }

    return res.status(200).json({ transactions });
  } catch (error) {
    console.error('Error fetching transactions in date range:', error);
    return res.status(500).json({ message: 'Error fetching transactions in date range', error });
  }
};

